<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Sistema de Acompanhamento de Chamados</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }
}

        body {
            padding: 20px;
            background-color: #f0f0f0;
        }


        #loginContainer {
            max-width: 300px;
            margin: 50px auto;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #mainContainer {
            display: none;
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        #slaStatistics {
            display: flex;
            justify-content: space-between;
            background-color: #f4f4f4;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
        }

        #slaStatistics .sla-stats {
            display: flex;
            gap: 20px;
        }

        #slaStatistics .sla-stats div {
            background-color: white;
            padding: 5px 10px;
            border-radius: 3px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        input, select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background-color: #007bff;
        }

        .ticket-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            padding: 15px;
            background-color: #f9f9f9;
            margin-bottom: 10px;
            border-radius: 4px;
            align-items: center;
        }

        .timer {
            font-size: 1.2em;
            font-weight: bold;
        }

        .green { background-color: #90EE90 !important; }
        .yellow { background-color: #FFFF99 !important; }
        .orange { background-color: #FFB366 !important; }
        .red { background-color: #FF9999 !important; }

        #ticketList {
            margin-top: 20px;
        }

        .error-message {
            color: red;
            margin-top: 5px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 10px;
            border: 1px solid #ddd;
            text-align: left;
        }

        th {
            background-color: #007bff;
        }
    </style>
</head>
<body>
    <div id="loginContainer">
        <h2>Login</h2>
        <div class="input-group">
            <label for="username">Usuário:</label>
            <input type="text" id="username" required>
        </div>
        <div class="input-group">
            <label for="password">Senha:</label>
            <input type="password" id="password" required>
        </div>
        <button onclick="login()">Entrar</button>
        <p id="loginError" class="error-message"></p>
    </div>

   <div id="mainContainer">
    <h1>Sistema de Acompanhamento de Chamados</h1>
    <button onclick="addNewTicket()">Adicionar Novo Chamado</button>
    <button onclick="showDatabase()">Visualizar Banco de Dados</button>
    <div id="ticketList"></div>

    <!-- Set display: none as the default style -->
    <div id="databaseView" style="display: none;">
        <div id="slaStatistics">
            <h3>Estatísticas de SLA</h3>
            <div class="sla-stats">
                <div>Total de Chamados: <span id="totalChamados">0</span></div>
                <div>Chamados no Prazo (T): <span id="chamadosNoPrazoT">0</span></div>
                <div>Chamados Fora do Prazo (T): <span id="chamadosForaPrazoT">0</span></div>
                <div>Chamados em Andamento (A): <span id="chamadosForaPrazoA">0</span></div>
            </div>
        </div>

        <h2>Registros de Chamados</h2>
        <div class="input-group">
            <label>Filtrar por PROBLEMA:</label>
            <input type="text" id="filterPR">
            <label>Filtrar por OPERADOR:</label>
            <input type="text" id="filterOP">
            <label>Filtrar por MÊS:</label>
            <input type="month" id="filterMonth">
            <button onclick="applyFilters()">Aplicar Filtros</button>
        </div>


<!-- Modify the showDatabase function -->
 <script>
        // Remove initialization of SLA statistics on page load
        document.addEventListener('DOMContentLoaded', () => {
            const databaseView = document.getElementById('databaseView');
            databaseView.style.display = 'none';
        });

        // Update the showDatabase function to manage visibility
        function showDatabase() {
            const databaseView = document.getElementById('databaseView');
            databaseView.style.display = databaseView.style.display === 'none' ? 'block' : 'none';
            
            if (databaseView.style.display === 'block') {
                updateDatabaseTable();
            }
        }

        // Update database table function remains the same but only updates SLA when database is visible
        function updateDatabaseTable(filters = {}) {
            const databaseView = document.getElementById('databaseView');
            if (databaseView.style.display === 'none') return;

            const tbody = document.getElementById('databaseTableBody');
            tbody.innerHTML = '';

            let filteredData = [...database];

            // Apply existing filters...
            if (filters.problema && filters.problema.trim() !== '') {
                filteredData = filteredData.filter(t => 
                    t.problema && t.problema.toLowerCase().includes(filters.problema.toLowerCase())
                );
            }
            if (filters.operador && filters.operador.trim() !== '') {
                filteredData = filteredData.filter(t => 
                    t.operador && t.operador.toLowerCase().includes(filters.operador.toLowerCase())
                );
            }
            if (filters.month && filters.month.trim() !== '') {
                const [filterYear, filterMonth] = filters.month.split('-');
                filteredData = filteredData.filter(t => {
                    if (!t.inicio) return false;
                    const ticketDate = new Date(t.inicio);
                    return ticketDate.getFullYear() === parseInt(filterYear) &&
                           ticketDate.getMonth() === (parseInt(filterMonth) - 1);
                });
            }

            // Update SLA statistics only when database is visible
            updateSLAStatistics(filteredData);

            // Render filtered data...
            filteredData.forEach(ticket => {
                const row = tbody.insertRow();
                const cells = [
                    ticket.tempo_previsto || '',
                    ticket.cliente || '',
                    ticket.problema || '',
                    ticket.operador || '',
                    ticket.executor || '',
                    ticket.inicio ? new Date(ticket.inicio).toLocaleString() : '',
                    ticket.arquivado_por || '',
                    ticket.fim || '',
                    ticket.tempo_decorrido || ''
                ];

                cells.forEach(value => {
                    const cell = row.insertCell();
                    cell.textContent = value;
                });
            });
        }

        // Rest of your JavaScript code remains the same...
    </script>
            <table id="databaseTable">
            <thead>
                <tr>
                    <th>TEMPO</th>
                    <th>CLIENTE</th>
                    <th>PROBLEMA</th>
                    <th>OPERADOR</th>
                    <th>EXECULTOR</th>
                    <th>HORA DE ABERTURA</th>
                    <th>ARQUIVADO POR:</th>
                    <th>HORA DE ENCERRAMENTO</th>
                    <th>TEMPO DE EXECUÇÃO</th>
                </tr>
            </thead>
            <tbody id="databaseTableBody"></tbody>
        </table>
    </div>
</div>

    <script>
        const users = [
            ["Jefferson", "123123"],
            ["Castelo", "123123"],
            ["Gabriel", "123123"],
            ["Kaline", "123123"],
            ["Julia", "123123"],
            ["Virgilio", "123123"],
            ["James", "123123"],
            ["Marcelo", "123123"]
        ];

        const operadores = ["", "Castelo", "Marcelo", "Julia", "kaline", "Gabriel", "Jeffeson"];
        const executores = ["", "Airton", "Damião", "Daniel", "Alison"];
        const problemas = ["","Acesso Lento","Acréscimo de canais","Adição de equipamento","Ajuste no IPV6","Ativação de Link","Ativação de Telefonia","Cliente entrou em contato pedindo uma informação tecnica","Falha elétrica no cliente”,“Falha elétrica no POP da Inovanet","Falha no equipamento da Inovanet","Falha no fornecimento de internet pela ALGAR","Falha no fornecimento de internet pela BR DIGITAL","Falha no link de transporte","Help Desk Presencial","Help Desk Remoto","Help Desk Telefonia","implantar cabo de internet","Mudança de endereço","Mudança de Equipamentos","Mudança de Local do Aparelho","Operadora de telefonia com falha de rotas","Orçamento","Outros","Portabilidade da linha","Problema na Hybrid","Problemas com páginas","Problemas no VOIP","Recolher equipamento","Rompimento do Backbone em Natal","Rompimento do drop do cliente em Ceará-Mirim","Rompimento do drop do cliente em Mossoró","Rompimento do drop do cliente em Natal","Rompimento do drop do cliente em Parnamirim","Rompimento no drop em STO","Rompimento no transporte da Intelnet","Rompimento no transporte para Ceará-Mirim","Rompimento no transporte para São José de Mipibu","Sem Acesso","Sem ping","Solicitação BGP","Solicitação de linha nova","Troca de CEO","Troca de conector tipo click","Troca de conector tipo RJ45","Troca de CTO","Troca de DROP","Troca de fonte com defeito","Troca de splitter"];
        const ncOpcoes = ["","476","490","135","240","306","317","318","169","110","184","40","65","224","251","370","214","215","342","520","199","467","242","457","22","327","498","500","417","216","248","210","247","80","24","152","51","195","69","205","358","115","119","50","549","550","191","365","13","151","470","405","359","334","404","399","407","55","424","462","469","535","435","222","176","319","570","441","436","437","438","43","446","225","323","15","491","54","109","515","538","539","553","552","21","483","264","37","88","4","245","354","501","447","494","475","418","182","26","512","572","157","187","361","536","243","217","582","579","442","310","198","160","8","161","158","137","165","212","305","140","534","532","132","235","303","433","2","311","285","229","409","465","521","153","527","196","332","5","328","324","408","211","519","422","421","78","471","174","73","67","403","338","102","238","201","396","428","410","406","580","489","518","180","181","260","577","492","559","188","44","297","479","524","148","87","453","108","452","236","444","454","445","448","449","308","309","76","565","466","170","171","360","374","371","555","156","146","484","516","514","197","254","255","413","378","456","507","523","104","185","289","496","463","537","60","18","36","290","316","425","27","257","529","584","574","458","495","48","427","368","213","241","43","517","190","499","522","509","510","511","583","124","431","551","228","322","321","262","394","352","275","315","263","283","280","270","276","295","246","353","302","232","451","506","343","286","325","485","220","189","575","155","573","414","505","143","144","123","330","480","434","96","17","493","531","145","347","557","432","271","416","223","450","369","478","571","576","298","391","388","389","393","390","162","340","204"]
        let database = JSON.parse(localStorage.getItem('ticketDatabase')) || [];
        let timers = new Map();
        let accumulatedTimes = new Map();

        function login() {
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            
            const user = users.find(u => u[0] === username && u[1] === password);
            
            if (user) {
                document.getElementById('loginContainer').style.display = 'none';
                document.getElementById('mainContainer').style.display = 'block';
            } else {
                document.getElementById('loginError').textContent = 'Usuário ou senha incorretos';
            }
        }

        function createSelect(options, id) {
            const select = document.createElement('select');
            select.id = id;
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                select.appendChild(opt);
            });
            return select;
        }

        function addNewTicket() {
            const ticketList = document.getElementById('ticketList');
            const ticketDiv = document.createElement('div');
            ticketDiv.className = 'ticket-row';
            
            const fields = {
                ts: document.createElement('input'),
                nc: createSelect(ncOpcoes, 'CLIENTE'),
                pr: createSelect(problemas, 'PROBLEMA'),
                op: createSelect(operadores, 'OPERADOR'),
                ex: createSelect(executores, 'EXECULTOR'),
                ha: document.createElement('input'),
                he: document.createElement('input')
            };

            fields.ha.readOnly = true;
            fields.ha.id = 'ha';
            fields.he.readOnly = true;
            fields.he.id = 'he';

            Object.entries(fields).forEach(([key, field]) => {
                const label = document.createElement('label');
                label.textContent = key.toUpperCase() + ':';
                ticketDiv.appendChild(label);
                ticketDiv.appendChild(field);
            });

            const timerDisplay = document.createElement('div');
            timerDisplay.className = 'timer';
            timerDisplay.textContent = 'T: 00:00:00';
            ticketDiv.setAttribute('data-timer-type', 'T');
            ticketDiv.setAttribute('data-timer-state', 'stopped');
            ticketDiv.setAttribute('data-accumulated-time', '0');
            
            const buttonContainer = document.createElement('div');
            const buttonLabels = ['Iniciar', 'Pausar', 'Arquivar', 'Excluir'];
            buttonLabels.forEach(text => {
                const button = document.createElement('button');
                button.textContent = text === 'Pausar' ? 'P' : text[0];
                button.onclick = () => handleTicketAction(text.toLowerCase(), ticketDiv);
                buttonContainer.appendChild(button);
            });

            ticketDiv.appendChild(timerDisplay);
            ticketDiv.appendChild(buttonContainer);
            ticketList.appendChild(ticketDiv);
        }

        function handleTicketAction(action, ticketDiv) {
    switch(action) {
        case 'iniciar':
            if (ticketDiv.getAttribute('data-timer-state') === 'stopped') {
                const tsInput = ticketDiv.querySelector('.input-time');
                if (!tsInput || !tsInput.value || !isValidTimeFormat(tsInput.value)) {
                    alert('Por favor, insira um tempo válido no formato H:M:S');
                    return;
                }
                const currentTime = new Date().toLocaleTimeString();
                const horaInicioInput = ticketDiv.querySelector('input[id="hora_inicio"]');
                if (horaInicioInput) {
                    horaInicioInput.value = currentTime;
                }
                startTimer(ticketDiv);
                ticketDiv.setAttribute('data-timer-state', 'running');
            }
            break;
        
        case 'pausar':
            const timerState = ticketDiv.getAttribute('data-timer-state');
            if (timerState === 'running') {
                const currentTime = new Date().toLocaleTimeString();
                const horaFimInput = ticketDiv.querySelector('input[id="hora_fim"]');
                if (horaFimInput) {
                    horaFimInput.value = currentTime;
                }
                const currentTimerValue = getTimerValue(ticketDiv);
                ticketDiv.setAttribute('data-last-time', currentTimerValue.toString());
                pauseTimer(ticketDiv);
                ticketDiv.setAttribute('data-timer-state', 'stopped');
            } else if (timerState === 'stopped') {
                const lastTime = parseInt(ticketDiv.getAttribute('data-last-time')) || 0;
                startTimer(ticketDiv, lastTime);
                ticketDiv.setAttribute('data-timer-state', 'running');
            }
            break;
        
        case 'arquivar':
            archiveTicket(ticketDiv);
            break;
        
        case 'excluir':
            validatePasswordAndExecute(() => {
                if (timers.has(ticketDiv)) {
                    clearInterval(timers.get(ticketDiv));
                    timers.delete(ticketDiv);
                }
                ticketDiv.remove();
            });
            break;
    }
}

function archiveTicket(ticketDiv) {
    validatePasswordAndExecute((username) => {
        const ticket = {
            tempo_previsto: ticketDiv.querySelector('.input-time').value,
            cliente: ticketDiv.querySelector('select[id="CLIENTE"]').value,
            problema: ticketDiv.querySelector('select[id="PROBLEMA"]').value,
            operador: ticketDiv.querySelector('select[id="OPERADOR"]').value,
            executor: ticketDiv.querySelector('select[id="EXECULTOR"]').value,
            inicio: new Date().toISOString(),
            arquivado_por: username,
            hora_inicio: ticketDiv.querySelector('input[id="hora_inicio"]').value,
            hora_fim: ticketDiv.querySelector('input[id="hora_fim"]').value,
            fim: new Date().toLocaleTimeString(),
            tempo_decorrido: ticketDiv.querySelector('.timer').textContent
        };

        // Adiciona o ticket ao banco de dados
        database.push(ticket);
        
        // Salva no localStorage
        localStorage.setItem('ticketDatabase', JSON.stringify(database));

        // Remove o ticket da lista atual
        ticketDiv.remove();
    });
}

// Função addNewTicket corrigida (parte relevante)
function addNewTicket() {
    // ... (código anterior permanece igual)
    
    const buttonContainer = document.createElement('div');
    const buttonLabels = ['IINICIAR', 'PAUSAR', 'ARQUIVAR', 'EXCLUIR'];
    buttonLabels.forEach(text => {
        const button = document.createElement('button');
        button.textContent = text;
        button.onclick = () => handleTicketAction(text.toLowerCase(), ticketDiv);
        buttonContainer.appendChild(button);
    });
    
    // ... (resto do código permanece igual)
}

// Função auxiliar para validar o formato do tempo
function isValidTimeFormat(timeStr) {
    return /^\d{1,2}:\d{1,2}:\d{1,2}$/.test(timeStr);
}

// Função startTimer corrigida
function startTimer(ticketDiv, resumeFrom = null) {
    const timerDisplay = ticketDiv.querySelector('.timer');
    const tsInput = ticketDiv.querySelector('.input-time');
    const ts = timeToSeconds(tsInput.value || '0:0:0');
    let timeLeft = resumeFrom !== null ? resumeFrom : ts;
    let timerType = ticketDiv.getAttribute('data-timer-type');

    if (timers.has(ticketDiv)) {
        clearInterval(timers.get(ticketDiv));
    }

    const timer = setInterval(() => {
        if (timerType === 'T' && timeLeft > 0) {
            timeLeft--;
            updateTimerDisplay(timerDisplay, timeLeft, 'T');
            updateTicketColor(ticketDiv, timeLeft / ts);
            
            if (timeLeft === 0) {
                timerType = 'A';
                ticketDiv.setAttribute('data-timer-type', 'A');
                timeLeft = 0;
                ticketDiv.classList.add('red');
            }
        } else {
            timeLeft++;
            updateTimerDisplay(timerDisplay, timeLeft, 'A');
            ticketDiv.classList.add('red');
        }
    }, 1000);

    timers.set(ticketDiv, timer);
}

function startTimer(ticketDiv, resumeFrom = null) {
    const timerDisplay = ticketDiv.querySelector('.timer');
    const ts = parseInt(ticketDiv.querySelector('input').value) || 0;
    let timeLeft = resumeFrom !== null ? resumeFrom : ts;
    let timerType = ticketDiv.getAttribute('data-timer-type');

    const timer = setInterval(() => {
        if (timerType === 'T' && timeLeft > 0) {
            timeLeft--;
            updateTimerDisplay(timerDisplay, timeLeft, 'T');
            updateTicketColor(ticketDiv, timeLeft / ts);
            
            if (timeLeft === 0) {
                timerType = 'A';
                ticketDiv.setAttribute('data-timer-type', 'A');
                timeLeft = 0;
                ticketDiv.classList.add('red');
            }
        } else {
            timeLeft++;
            updateTimerDisplay(timerDisplay, timeLeft, 'A');
            ticketDiv.classList.add('red');
        }
    }, 1000);

    timers.set(ticketDiv, timer);
}

function calculateSLAStatistics(data) {
    const stats = {
        totalChamados: data.length,
        chamadosAbertos: 0,
        chamadosFechados: 0,
        chamadosNoPrazo: 0,
        chamadosForaPrazoT: 0,
        chamadosForaPrazoA: 0
    };

    data.forEach(ticket => {
        // Lógica para determinar status do chamado
        const tempoPrevistoString = ticket.tempo_previsto || '0:0:0';
        const tempoPrevistoSegundos = timeToSeconds(tempoPrevistoString);
        const tempoDecorridoString = ticket.tempo_decorrido || 'T: 00:00:00';
        const [tipoTempo, tempoDecorrido] = tempoDecorridoString.split(': ');
        const tempoDecorridoSegundos = timeToSeconds(tempoDecorrido);

        // Determinando status por tipo de tempo
        if (tipoTempo === 'T') {
            // Chamado em tempo previsto
            if (tempoDecorridoSegundos > tempoPrevistoSegundos) {
                stats.chamadosForaPrazoT++;
            } else {
                stats.chamadosNoPrazo++;
            }
        } else if (tipoTempo === 'A') {
            // Chamado após tempo previsto
            stats.chamadosForaPrazoA++;
        }

        // Contagem de chamados abertos/fechados
        if (ticket.hora_fim) {
            stats.chamadosFechados++;
        } else {
            stats.chamadosAbertos++;
        }
    });

    return stats;
}

function calculateSLAStatistics(data) {
    const stats = {
        totalChamados: data.length,
        chamadosAbertos: 0,
        chamadosFechados: 0,
        chamadosNoPrazo: 0,
        chamadosForaPrazoT: 0,
        chamadosForaPrazoA: 0
    };

    console.log('Dados para SLA:', data); // Debug

    data.forEach(ticket => {
        // Incrementa total de chamados
        if (ticket.tempo_decorrido) {
            // Verifica tipo de tempo
            const [tipoTempo, tempoDecorrido] = ticket.tempo_decorrido.split(': ');
            
            // Converte tempos para segundos
            const tempoPrevistoSegundos = ticket.tempo_previsto ? timeToSeconds(ticket.tempo_previsto) : 0;
            const tempoDecorridoSegundos = timeToSeconds(tempoDecorrido);

            // Lógica de classificação
            if (tipoTempo === 'T') {
                // Chamado em tempo previsto
                if (tempoDecorridoSegundos > tempoPrevistoSegundos) {
                    stats.chamadosForaPrazoT++;
                } else {
                    stats.chamadosNoPrazo++;
                }
            } else if (tipoTempo === 'A') {
                // Chamado após tempo previsto
                stats.chamadosForaPrazoA++;
            }
        }

        // Contagem de chamados abertos/fechados
        if (ticket.hora_fim) {
            stats.chamadosFechados++;
        } else {
            stats.chamadosAbertos++;
        }
    });

    return stats;
}

function updateSLAStatistics(data) {
    const slaStatistics = document.getElementById('slaStatistics');
    
    // Sempre mostrar estatísticas, independente de filtros
    slaStatistics.style.display = 'block';

    const stats = calculateSLAStatistics(data);

    console.log('Estatísticas SLA:', stats); // Debug

    // Atualiza os elementos com as estatísticas
    document.getElementById('totalChamados').textContent = stats.totalChamados;
    document.getElementById('chamadosAbertos').textContent = stats.chamadosAbertos;
    document.getElementById('chamadosFechados').textContent = stats.chamadosFechados;
    document.getElementById('chamadosNoPrazo').textContent = stats.chamadosNoPrazo;
    document.getElementById('chamadosForaPrazoT').textContent = stats.chamadosForaPrazoT;
    document.getElementById('chamadosForaPrazoA').textContent = stats.chamadosForaPrazoA;
}

// Modificar a função updateDatabaseTable para incluir a atualização de estatísticas
function updateDatabaseTable(filters = {}) {
    const tbody = document.getElementById('databaseTableBody');
    tbody.innerHTML = '';

    let filteredData = [...database];

    // Aplicar filtros existentes
    if (filters.problema && filters.problema.trim() !== '') {
        filteredData = filteredData.filter(t => 
            t.problema && t.problema.toLowerCase().includes(filters.problema.toLowerCase())
        );
    }
    if (filters.operador && filters.operador.trim() !== '') {
        filteredData = filteredData.filter(t => 
            t.operador && t.operador.toLowerCase().includes(filters.operador.toLowerCase())
        );
    }
    if (filters.month && filters.month.trim() !== '') {
        const [filterYear, filterMonth] = filters.month.split('-');
        filteredData = filteredData.filter(t => {
            if (!t.inicio) return false;
            const ticketDate = new Date(t.inicio);
            return ticketDate.getFullYear() === parseInt(filterYear) &&
                   ticketDate.getMonth() === (parseInt(filterMonth) - 1);
        });
    }

    // Atualizar estatísticas de SLA
    updateSLAStatistics(filteredData);

    // Renderizar dados filtrados
    filteredData.forEach(ticket => {
        const row = tbody.insertRow();
        const cells = [
            ticket.tempo_previsto || '',
            ticket.cliente || '',
            ticket.problema || '',
            ticket.operador || '',
            ticket.executor || '',
            ticket.inicio ? new Date(ticket.inicio).toLocaleString() : '',
            ticket.arquivado_por || '',
            ticket.fim || '',
            ticket.tempo_decorrido || ''
        ];

        cells.forEach(value => {
            const cell = row.insertCell();
            cell.textContent = value;
        });
    });
}

// Função auxiliar para converter tempo em segundos
function timeToSeconds(timeStr) {
    if (!timeStr) return 0;
    const parts = timeStr.split(':').map(Number);
    // Garantir que tenha 3 partes
    while (parts.length < 3) parts.unshift(0);
    return parts[0] * 3600 + parts[1] * 60 + parts[2];
}

// Chamar na inicialização
document.addEventListener('DOMContentLoaded', () => {
    // Inicializa estatísticas com todos os dados
    updateSLAStatistics(database);
});

// Modificar a função de arquivamento para atualizar estatísticas
function archiveTicket(ticketDiv) {
    validatePasswordAndExecute((username) => {
        // Coleta todos os valores necessários
        const ticket = {
            tempo_previsto: ticketDiv.querySelector('input[type="text"]').value,
            cliente: ticketDiv.querySelector('select[id="CLIENTE"]').value,
            problema: ticketDiv.querySelector('select[id="PROBLEMA"]').value,
            operador: ticketDiv.querySelector('select[id="OPERADOR"]').value,
            executor: ticketDiv.querySelector('select[id="EXECULTOR"]').value,
            hora_inicio: ticketDiv.querySelector('input[id="hora_inicio"]').value,
            hora_fim: new Date().toLocaleTimeString(), // Define hora de fim como hora atual
            arquivado_por: username,
            inicio: new Date().toISOString(),
            fim: new Date().toLocaleTimeString(),
            tempo_decorrido: ticketDiv.querySelector('.timer').textContent
        };

        // Verifica se há dados essenciais antes de arquivar
        if (!ticket.cliente || !ticket.problema || !ticket.operador || !ticket.executor) {
            alert('Por favor, preencha todos os campos obrigatórios antes de arquivar.');
            return;
        }

        // Adiciona o ticket ao banco de dados
        database.push(ticket);
        
        // Salva no localStorage
        localStorage.setItem('ticketDatabase', JSON.stringify(database));

        // Para o timer se estiver rodando
        if (timers.has(ticketDiv)) {
            clearInterval(timers.get(ticketDiv));
            timers.delete(ticketDiv);
        }

        // Remove o ticket da lista atual
        ticketDiv.remove();

        // Atualiza as estatísticas
        updateSLAStatistics(database);

        // Atualiza a visualização do banco de dados se estiver aberta
        const databaseView = document.getElementById('databaseView');
        if (databaseView.style.display === 'block') {
            updateDatabaseTable();
        }

        alert('Chamado arquivado com sucesso!');
    });
}

function calculateSLAStatistics(data) {
    const stats = {
        totalChamados: 0,
        chamadosNoPrazoT: 0,
        chamadosForaPrazoT: 0,
        chamadosForaPrazoA: 0
    };

    data.forEach(ticket => {
        // Verificar se o ticket tem tempo decorrido
        if (ticket.tempo_decorrido) {
            stats.totalChamados++;
            
            const [tipoTempo, tempoDecorrido] = ticket.tempo_decorrido.split(': ');
            
            if (tipoTempo === 'T') {
                const tempoPrevistoSegundos = timeToSeconds(ticket.tempo_previsto || '0:0:0');
                const tempoDecorridoSegundos = timeToSeconds(tempoDecorrido);

                if (tempoDecorridoSegundos <= tempoPrevistoSegundos) {
                    stats.chamadosNoPrazoT++;
                } else {
                    stats.chamadosForaPrazoT++;
                }
            } else if (tipoTempo === 'A') {
                stats.chamadosForaPrazoA++;
            }
        }
    });

    return stats;
}

function updateSLAStatistics(data) {
    const stats = calculateSLAStatistics(data);

    document.getElementById('totalChamados').textContent = stats.totalChamados;
    document.getElementById('chamadosNoPrazoT').textContent = stats.chamadosNoPrazoT;
    document.getElementById('chamadosForaPrazoT').textContent = stats.chamadosForaPrazoT;
    document.getElementById('chamadosForaPrazoA').textContent = stats.chamadosForaPrazoA;
}

function updateDatabaseTable(filters = {}) {
    const tbody = document.getElementById('databaseTableBody');
    tbody.innerHTML = '';

    let filteredData = [...database];

    // Aplicar filtros existentes
    if (filters.problema && filters.problema.trim() !== '') {
        filteredData = filteredData.filter(t => 
            t.problema && t.problema.toLowerCase().includes(filters.problema.toLowerCase())
        );
    }
    if (filters.operador && filters.operador.trim() !== '') {
        filteredData = filteredData.filter(t => 
            t.operador && t.operador.toLowerCase().includes(filters.operador.toLowerCase())
        );
    }
    if (filters.month && filters.month.trim() !== '') {
        const [filterYear, filterMonth] = filters.month.split('-');
        filteredData = filteredData.filter(t => {
            if (!t.inicio) return false;
            const ticketDate = new Date(t.inicio);
            return ticketDate.getFullYear() === parseInt(filterYear) &&
                   ticketDate.getMonth() === (parseInt(filterMonth) - 1);
        });
    }

    // Atualizar estatísticas de SLA
    updateSLAStatistics(filteredData);

    // Renderizar dados filtrados
    filteredData.forEach(ticket => {
        const row = tbody.insertRow();
        const cells = [
            ticket.tempo_previsto || '',
            ticket.cliente || '',
            ticket.problema || '',
            ticket.operador || '',
            ticket.executor || '',
            ticket.inicio ? new Date(ticket.inicio).toLocaleString() : '',
            ticket.arquivado_por || '',
            ticket.fim || '',
            ticket.tempo_decorrido || ''
        ];

        cells.forEach(value => {
            const cell = row.insertCell();
            cell.textContent = value;
        });
    });
}
function timeToSeconds(timeStr) {
    if (!timeStr) return 0;
    const parts = timeStr.split(':').map(Number);
    // Garantir que tenha 3 partes
    while (parts.length < 3) parts.unshift(0);
    return parts[0] * 3600 + parts[1] * 60 + parts[2];
}

// Inicialização com todos os dados
document.addEventListener('DOMContentLoaded', () => {
    updateSLAStatistics(database);
});

function getTimerValue(ticketDiv) {
    const timerDisplay = ticketDiv.querySelector('.timer').textContent;
    const [, timeStr] = timerDisplay.split(': ');
    const [hours, minutes, seconds] = timeStr.split(':').map(Number);
    return hours * 3600 + minutes * 60 + seconds;
}

function pauseTimer(ticketDiv) {
    if (timers.has(ticketDiv)) {
        clearInterval(timers.get(ticketDiv));
        timers.delete(ticketDiv);
    }
}

function updateTimerDisplay(display, time, prefix) {
    const hours = Math.floor(time / 3600);
    const minutes = Math.floor((time % 3600) / 60);
    const seconds = time % 60;
    display.textContent = `${prefix}: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

        function updateTicketColor(ticketDiv, percentage) {
            ticketDiv.className = 'ticket-row';
            if (percentage > 0.75) ticketDiv.classList.add('green');
            else if (percentage > 0.5) ticketDiv.classList.add('yellow');
            else if (percentage > 0.25) ticketDiv.classList.add('orange');
            else ticketDiv.classList.add('red');
        }
function addNewTicket() {
    const ticketList = document.getElementById('ticketList');
    const ticketDiv = document.createElement('div');
    ticketDiv.className = 'ticket-row';
    
    const fields = {
        tempo_previsto: document.createElement('input'),
        CLIENTE: createSelect(ncOpcoes, 'CLIENTE'),
        PROBLEMA: createSelect(problemas, 'PROBLEMA'),
        OPERADOR: createSelect(operadores, 'OPERADOR'),
        EXECULTOR: createSelect(executores, 'EXECULTOR'),
        hora_inicio: document.createElement('input'),
        hora_fim: document.createElement('input')
    };

    // Configure input fields
    fields.tempo_previsto.type = 'text';
    fields.tempo_previsto.className = 'input-time';
    fields.tempo_previsto.placeholder = 'H:M:S';
    
    // Input formatting for time
    fields.tempo_previsto.addEventListener('input', function(e) {
        // Remove non-numeric characters except ':'
        e.target.value = e.target.value.replace(/[^0-9:]/g, '');
    });

    fields.tempo_previsto.addEventListener('blur', function(e) {
        if (e.target.value) {
            let parts = e.target.value.split(':');
            // Pad with zeros and limit to 3 parts
            parts = parts.map(part => part.padStart(2, '0'));
            while (parts.length < 3) parts.push('00');
            e.target.value = parts.slice(0, 3).join(':');
        }
    });

    // Set read-only fields
    fields.hora_inicio.readOnly = true;
    fields.hora_inicio.id = 'hora_inicio';
    fields.hora_fim.readOnly = true;
    fields.hora_fim.id = 'hora_fim';

    // Create labels and append fields
    Object.entries(fields).forEach(([key, field]) => {
        const label = document.createElement('label');
        label.textContent = {
            'tempo_previsto': 'TEMPO PREVISTO:',
            'hora_inicio': 'HORA DE INÍCIO:',
            'hora_fim': 'HORA DE FIM:'
        }[key] || key.toUpperCase() + ':';
        ticketDiv.appendChild(label);
        ticketDiv.appendChild(field);
    });

    // Timer display
    const timerDisplay = document.createElement('div');
    timerDisplay.className = 'timer';
    timerDisplay.textContent = 'T: 00:00:00';
    ticketDiv.setAttribute('data-timer-type', 'T');
    ticketDiv.setAttribute('data-timer-state', 'stopped');
    ticketDiv.setAttribute('data-accumulated-time', '0');
    
    // Button container
    const buttonContainer = document.createElement('div');
    const buttonActions = [
        { text: 'INICIAR', handler: 'iniciar' },
        { text: 'PAUSAR', handler: 'pausar' },
        { text: 'ARQUIVAR', handler: 'arquivar' },
        { text: 'EXCLUIR', handler: 'excluir' }
    ];

    buttonActions.forEach(({ text, handler }) => {
        const button = document.createElement('button');
        button.textContent = text;
        button.onclick = () => handleTicketAction(handler, ticketDiv);
        buttonContainer.appendChild(button);
    });

    ticketDiv.appendChild(timerDisplay);
    ticketDiv.appendChild(buttonContainer);
    ticketList.appendChild(ticketDiv);
}


        function isValidTimeFormat(timeStr) {
            return /^\d{1,2}:\d{1,2}:\d{1,2}$/.test(timeStr);
        }

        function timeToSeconds(timeStr) {
            const [hours, minutes, seconds] = timeStr.split(':').map(Number);
            return hours * 3600 + minutes * 60 + seconds;
        }

        function startTimer(ticketDiv, resumeFrom = null) {
            const timerDisplay = ticketDiv.querySelector('.timer');
            const tsInput = ticketDiv.querySelector('input');
            const ts = timeToSeconds(tsInput.value || '0:0:0');
            let timeLeft = resumeFrom !== null ? resumeFrom : ts;
            let timerType = ticketDiv.getAttribute('data-timer-type');

            const timer = setInterval(() => {
                if (timerType === 'T' && timeLeft > 0) {
                    timeLeft--;
                    updateTimerDisplay(timerDisplay, timeLeft, 'T');
                    updateTicketColor(ticketDiv, timeLeft / ts);
                    
                    if (timeLeft === 0) {
                        timerType = 'A';
                        ticketDiv.setAttribute('data-timer-type', 'A');
                        timeLeft = 0;
                        ticketDiv.classList.add('red');
                    }
                } else {
                    timeLeft++;
                    updateTimerDisplay(timerDisplay, timeLeft, 'A');
                    ticketDiv.classList.add('red');
                }
            }, 1000);

            timers.set(ticketDiv, timer);
        }

        function archiveTicket(ticketDiv) {
            validatePasswordAndExecute((username) => {
                // Coleta todos os valores necessários
                const ticket = {
                    tempo_previsto: ticketDiv.querySelector('input[type="text"]').value,
                    cliente: ticketDiv.querySelector('select[id="CLIENTE"]').value,
                    problema: ticketDiv.querySelector('select[id="PROBLEMA"]').value,
                    operador: ticketDiv.querySelector('select[id="OPERADOR"]').value,
                    executor: ticketDiv.querySelector('select[id="EXECULTOR"]').value,
                    hora_inicio: ticketDiv.querySelector('input[id="hora_inicio"]').value,
                    hora_fim: new Date().toLocaleTimeString(), // Define hora de fim como hora atual
                    arquivado_por: username,
                    inicio: ticketDiv.querySelector('input[id="hora_inicio"]').value,
                    fim: new Date().toLocaleTimeString(),
                    tempo_decorrido: ticketDiv.querySelector('.timer').textContent
                };

                // Verifica se há dados essenciais antes de arquivar
                if (!ticket.cliente || !ticket.problema || !ticket.operador || !ticket.executor) {
                    alert('Por favor, preencha todos os campos obrigatórios antes de arquivar.');
                    return;
                }

                // Adiciona o ticket ao banco de dados
                database.push(ticket);
                
                // Salva no localStorage
                localStorage.setItem('ticketDatabase', JSON.stringify(database));

                // Para o timer se estiver rodando
                if (timers.has(ticketDiv)) {
                    clearInterval(timers.get(ticketDiv));
                    timers.delete(ticketDiv);
                }

                // Remove o ticket da lista atual
                ticketDiv.remove();

                // Atualiza a visualização do banco de dados se estiver aberta
                const databaseView = document.getElementById('databaseView');
                if (databaseView.style.display === 'block') {
                    updateDatabaseTable();
                }

                alert('Chamado arquivado com sucesso!');
            });
        }

        function validatePasswordAndExecute(callback) {
            const username = prompt('Digite seu nome de usuário:');
            const password = prompt('Digite sua senha:');
            
            const user = users.find(u => u[0] === username && u[1] === password);
        
            if (user) {
                callback(username);
            } else {
                alert('Usuário ou senha incorretos!');
        }
    }


        function calculateTotalTime(ticketDiv) {
            const hora_inicio = ticketDiv.querySelector('input[id="hora_inicio"]').value;
            const hora_fim = ticketDiv.querySelector('input[id="hora_fim"]').value;
            if (!hora_inicio || !hora_fim) return "00:00:00";
            
            const start = new Date(`1970/01/01 ${hora_inicio}`);
            const end = new Date(`1970/01/01 ${hora_fim}`);
            const diff = Math.floor((end - start) / 1000);
            
            const hours = Math.floor(diff / 3600);
            const minutes = Math.floor((diff % 3600) / 60);
            const seconds = diff % 60;
            
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }


        function showDatabase() {
            const databaseView = document.getElementById('databaseView');
            databaseView.style.display = databaseView.style.display === 'none' ? 'block' : 'none';
            if (databaseView.style.display ==='block') {
                updateDatabaseTable();
            }
        }

        function updateDatabaseTable(filters = {}) {
            const tbody = document.getElementById('databaseTableBody');
            tbody.innerHTML = '';

            console.log('Database:', database); // Para debug
            console.log('Filtros aplicados:', filters); // Para debug

            let filteredData = [...database];

            if (filters.problema && filters.problema.trim() !== '') {
                filteredData = filteredData.filter(t => {
                    return t.problema && t.problema.toLowerCase().includes(filters.problema.toLowerCase());
        });
    }
            if (filters.operador && filters.operador.trim() !== '') {
                filteredData = filteredData.filter(t => {
                    return t.operador && t.operador.toLowerCase().includes(filters.operador.toLowerCase());
        });
    }
    if (filters.month && filters.month.trim() !== '') {
        const [filterYear, filterMonth] = filters.month.split('-');
        filteredData = filteredData.filter(t => {
            if (!t.inicio) return false;
            const ticketDate = new Date(t.inicio);
            if (isNaN(ticketDate.getTime())) return false;

            return ticketDate.getFullYear() === parseInt(filterYear) &&
                   ticketDate.getMonth() === (parseInt(filterMonth) - 1);
        });
    }

    console.log('Dados filtrados:', filteredData);

    filteredData.forEach(ticket => {
        const row = tbody.insertRow();
        const cells = [
            ticket.tempo_previsto || '',
            ticket.cliente || '',
            ticket.problema || '',
            ticket.operador || '',
            ticket.executor || '',
            ticket.inicio ? new Date(ticket.inicio).toLocaleString() : '',
            ticket.arquivado_por || '',
            ticket.fim || '',
            ticket.tempo_decorrido || ''
        ];

        cells.forEach(value => {
            const cell = row.insertCell();
            cell.textContent = value;
        });
    });
}

        function applyFilters() {
            const filters = {
                problema: document.getElementById('filterPR').value,
                operador: document.getElementById('filterOP').value,
                month: document.getElementById('filterMonth').value

    };

        console.log('Aplicando filtros:', filters); // Para debug
        updateDatabaseTable(filters);
}

function clearDatabase() {
    if (confirm('Tem certeza que deseja limpar o banco de dados?')) {
        database = [];
        localStorage.setItem('ticketDatabase', JSON.stringify(database));
        updateDatabaseTable();
    }
}

    </script>
</body>
</html>
